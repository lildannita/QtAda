Как можно будет симулировать нажатие на объект:
    QByteArray subString = "mousearea";
    QByteArray teststr = metaObj->className();
    bool containsSubstring = teststr.toLower().contains(subString.toLower());
    if (containsSubstring) {
        QQuickItem *mouseArea = qobject_cast<QQuickItem*>(obj);
        qreal width = mouseArea->width();
        qreal height = mouseArea->height();
        // Вычисление координат центра
        QPointF centerPos(width / 2, height / 2);
        QMouseEvent pressEvent(QEvent::MouseButtonPress, centerPos, Qt::LeftButton, Qt::LeftButton, Qt::NoModifier);
        QMouseEvent releaseEvent(QEvent::MouseButtonRelease, centerPos, Qt::LeftButton, Qt::LeftButton, Qt::NoModifier);
        QCoreApplication::sendEvent(mouseArea, &pressEvent);
        QCoreApplication::sendEvent(mouseArea, &releaseEvent);
    }

Как можно будет рисовать прямоугольник вокруг объектов:
QWidget:
#include <QFrame>
    auto* widget = qobject_cast<QWidget*>(obj);
    QFrame* frame = new QFrame(widget);
    frame->setFrameShape(QFrame::Box);
    frame->setFrameShadow(QFrame::Raised);
    frame->setLineWidth(2);
    frame->setMidLineWidth(0);
    frame->setPalette(QPalette(Qt::red));
    frame->setAutoFillBackground(false);
    frame->setGeometry(widget->rect());
    frame->show();


QQuickItem:

#include <QQuickItem>
#include <QQuickPaintedItem>
#include <QPainter>

class BorderPainter : public QQuickPaintedItem {
public:
    BorderPainter(QQuickItem* parent = nullptr) : QQuickPaintedItem(parent) {
        if (parent) {
            setParentItem(parent);
            setWidth(parent->width());
            setHeight(parent->height());
        }
    }

    void paint(QPainter* painter) override {
        painter->setPen(QPen(Qt::red, 2)); // Установка цвета и толщины кисти
        painter->drawRect(boundingRect().adjusted(1, 1, -1, -1)); // Рисуем прямоугольник
    }
};

    QQuickItem* item = qobject_cast<QQuickItem*>(obj);
    new BorderPainter(item);


Как решить проблему с тем, что диалог тестируемого приложения перекрывает ControlDialog:
    ->  Можно попробовать перехватывать создание диалогов в Probe::addObject и делать их не модальными: setWindowModality(Qt::NonModal);

Как решить проблему с тем, что мы не можем показать ControlDialog для QML:
    ->  Нужно перехватывать создание QQmlApplicationEngine и подгружать туда свой QML-код, который будет являться копией диалога на QtWidgets
